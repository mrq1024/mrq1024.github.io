---
editLink: false
sidebar: false
---

## 参考
[如何理解js执行上下文](https://segmentfault.com/a/1190000041692494)  
[JavaScript深入之变量对象](https://github.com/mqyqingfeng/Blog/issues/5)  
[(ES5版)深入理解 JavaScript 执行上下文和执行栈](https://jishuin.proginn.com/p/763bfbd23ab4)

## 执行上下文
执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。 

每次当控制器转到可执行代码的时候,就会进入一个执行上下文.执行上下文可以理解为当前代码的执行环境,它会形成一个作用域.

主要记录了执行过程的中的状态信息.

代码执行结束,执行上下文也会销毁


### 执行上下文分类
JavaScript执行上下文分为下面3类
- 全局执行上下文
- 函数执行上下文
- eval执行上下文(一般不会使用,这是不讨论)

##### 全局执行上下文
全局执行上下文只有一个，在客户端中一般由浏览器创建，也就是window对象，通过this可以直接访问到它。

全局对象window上预定义了大量的方法和属性，在全局环境的任意处都能直接访问这些属性方法.

同时window对象还是var声明的全局变量的载体。通过var创建的全局对象，都可以通过window直接访问。

##### 函数执行上下文

函数执行上下文可存在无数个，每当一个函数被调用时都会创建一个函数上下文
::: tip
同一个函数被多次调用，都会创建一个新的上下文
:::

### 执行上下文栈&&Event Loop执行机制

##### 执行栈
因此在一个Javascript程序中,必定会产生多个执行上下文,JavaScript以堆栈的方式来处理它们.  
栈底永远是全局执行上下文,而栈顶就是当前正在执行的上下文  

在代码执行过程中,遇到以上三种情况,都会产生一个执行上下文,放入栈中,而处于栈顶的执行上下文执行完毕后,就会自动出栈.

##### Event Loop
Event Loop事件循环是JS的执行机制。因为js引擎线程是单线程的，为了合理地安排同步任务和异步任务的执行，定义了事件循环机制来协调。Event Loop会先执行完处于执行栈中的任务后，然后从事件队列读取事件，添加到执行栈中执行，如此循环。


### ES3执行上下文内容
在ES3的定义中,执行上下包括:
- [变量对象](./variableObject.md)
- [作用域链](./scopeChain.md)
- [this](./this.md)

### ES3执行上下文生命周期

##### 创建阶段
- 初始化变量
    - 如果是函数执行上下文，会以参数列表(arguments)初始化变量对象，以及将函数内部的变量声明、函数声明添加到变量对象。
    - 在这一阶段，会进行变量和函数的初始化声明，变量定义为undefined，而函数直接定义。即变量提升，变量和函数都会提升，但函数会更靠前。
- 构建作用域链
- 确定this值

##### 执行阶段
JS代码开始逐句执行，顺着作用域链访问变量、为之前声明的变量赋值、碰到函数调用则创建新的函数执行上下文压入栈中，并把控制权交出。

##### 销毁阶段
函数执行完成后，会将当前上下文弹出执行栈进行销毁，将控制权交回给上一层的执行上下文。

但是闭包的情况有所不同。

当包裹闭包函数的父函数执行完毕后，父函数本身执行环境的作用域链被销毁，但是由于闭包函数有对父函数变量的引用，导致父函数的变量对象一直存在于内存，无法被销毁，除非闭包的引用被删除。

::: tip
过多使用闭包导致不再用到的内存，没有及时释放，有可能发生“内存泄露”。
:::



### ES5执行上下文内容
ES5对执行上下文的概念做了调整，去掉了`变量对象`、`活动对象`，用`词法环境组件(LexicalEnvironment component)`和`变量环境(VariableEnvironment component)组件`代替。

ES5 的执行上下文概念上表示大概如下:
```javascript
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
```

#### 词法环境
> 词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用outer词法环境的空值组成。  

简单来说,词法环境就是标识符--变量的映射的结构:
- **标识符**:变量/函数名字
- **变量**:对实际对象的引用或基础数据类型的值

词法环境内部有两个组件
- **环境记录器**:存储变量和函数声明的实际位置
- **外部环境引用**:它可以访问其父级词法环境(作用域)

::: tip
外部环境已经跟 ES3 规定的作用域的作用类似
:::

##### 词法环境类型
- 全局环境:（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 null。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且`this`的值指向全局对象。

- 函数环境:函数内部用户定义的变量存储在环境记录器中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。

环境记录器也分两种情况
- **声明式环境记录器**:存储变量、函数和参数。
- **对象环境记录器**:用来定义出现在全局上下文中的变量和函数的关系。


简而言之，
- 在全局环境中，环境记录器是对象环境记录器。  
- 在函数环境中，环境记录器是声明式环境记录器。

::: tip
对于函数环境，声明式环境记录器还包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。
:::


#### 变量环境
同样是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。
在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（`let`和`const`）绑定，而后者只用来存储`var`变量绑定。

### ES5 执行上下文总结

 - 1.程序启动，全局上下文被创建

    - 1.创建全局上下文的 词法环境

      - 1.创建 对象环境记录器 ，它用来定义出现在 全局上下文 中的变量和函数的关系（负责处理 let 和 const 定义的变量）
      - 2.创建 外部环境引用，值为 null


    - 2.创建全局上下文的 变量环境

      - 1.创建 对象环境记录器，它持有 变量声明语句 在执行上下文中创建的绑定关系（负责处理 var 定义的变量，初始值为 undefined 造成声明提升）
      - 2.创建 外部环境引用，值为 null


    - 3.确定 this 值为全局对象（以浏览器为例，就是 window ）


  - 2.函数被调用，函数上下文被创建

    - 1.创建函数上下文的 词法环境

      - 1.创建  声明式环境记录器 ，存储变量、函数和参数，它包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。（负责处理 let 和 const 定义的变量）
      - 2.创建 外部环境引用，值为全局对象，或者为父级词法环境（作用域）
    - 2.创建函数上下文的 变量环境

      - 1.创建  声明式环境记录器 ，存储变量、函数和参数，它包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。（负责处理 var 定义的变量，初始值为 undefined 造成声明提升）
      - 2.创建 外部环境引用，值为全局对象，或者为父级词法环境（作用域）
    - 3.确定 this 值


- 3.进入函数执行上下文的执行阶段：

  - 1.在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。